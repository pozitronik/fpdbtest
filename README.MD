[![Build Status](https://github.com/pozitronik/fpdbtest/actions/workflows/ci.yml/badge.svg)](https://github.com/pozitronik/fpdbtest/actions)

Решение [тестового задания](/src/README.txt).

Для удобства приложенные к заданию тесты оформлены в виде unit-тестов Codeception + написаны дополнительные тесты, код в `tests\Unit\`. Для запуска потребуется установка пакетов через `composer install` (либо можно собрать docker-образ через `docker-compose up -d --build` и запускать в нём). Запуск тестов: `php vendor/bin/codecept run`.

# Комментарии к заданию
1. В задании не указано прямо, как должны трактоваться маркеры в отдельных случаях, например - внутри строк (`SELECT * FROM table WHERE term like 'question? '`), должна ли быть возможность их экранирования. Исходя из своего опыта, я принял решение, что маркер всегда считается специальным символом, однако должна быть возможность его экранирования. Для этого сдвоенный маркер `??` должен преобразовываться в `?` (аналогично поведению кавычек в строках (`''` -> `'`)). Это поведение может быть изменено флагом `$allowMarkerEscape`, при его отключении `??` будет трактоваться как два маркера без параметров.
2. Схожая ситуация с маркерами условных блоков. `{` и `}` могут быть использованы внутри строк и как символы, и для обозначения условия, и внутри регулярных выражений. Поэтому я добавил для них экранирование, аналогичное экранированию в PCRE: `/{` и `/}` всегда преобразуются в `{` и `}`, и не трактуются, как маркеры.
3. В задании указано, что при ошибках должны выбрасываться исключения, но нет указаний, что должно считаться ошибкой. Например, как реагировать, если количество параметров не совпадёт с количеством маркеров? Опытный разработчик должен сам продумывать подобные ситуации. Я посчитал, что любая неопределённость ведёт к потенциальной ошибке, и заложил в код именно такую трактовку.
4. ...кроме тех случаев, когда неопределённость не нарушает логику задания. `?#` - это массив идентификаторов, но что, если идентификатор использован в ненадлежащем месте (и формирует некорректный SQL)? Что, если список идентификаторов задан ассоциативным массивом (хотя требуется просто набор значений)? Я ответил на подобные вопросы в коде тестов.

Алгоритм решения достаточно читаем, но опишу его верхнеуровнево:
   - Строка на входе разбивается на подстроки по количеству безусловных и условных блоков (`'a?bcd{e?f}{gh}i'` => `['a?bcd', 'e?f', 'gh', 'i']`), каждый блок маркируется флагом условности. На этом же этапе проверяется корректность условных блоков и отсутствие их вложенности.
   - В каждой подстроке происходит поиск маркеров, с заменой их на соответствующий аргумент. Аргументы форматируются и преобразуются в строки согласно заданию, для условных выражений проверяется наличие спецмаркера пропуска (с игнорированием всей подстроки в этом случае). На этом же этапе проводится проверка достаточности аргументов и их корректность. 
   - Итоговые соединяются в результирующую строку, тут же проверяется избыточность аргументов.
Поскольку в задании прямо указана недопустимость вложенных условных блоков, этот подход видится мне наиболее подходящим.

